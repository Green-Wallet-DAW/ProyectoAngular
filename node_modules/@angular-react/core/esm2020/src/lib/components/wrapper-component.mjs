/// <reference path="../@types/geteventlisteners.d.ts" />
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/// <reference path="../@types/geteventlisteners.d.ts" />
import { Input, Directive } from '@angular/core';
import classnames from 'classnames';
import toStyle from 'css-to-style';
import stylenames from 'stylenames';
import { isReactNode } from '../renderer/react-node';
import { isReactRendererData } from '../renderer/renderer';
import { toObject } from '../utils/object/to-object';
import { afterRenderFinished } from '../utils/render/render-delay';
import { createInputJsxRenderer, createRenderPropHandler } from './render-props';
import * as i0 from "@angular/core";
// Forbidden attributes are still ignored, since they may be set from the wrapper components themselves (forbidden is only applied for users of the wrapper components)
const ignoredAttributeMatchers = [/^_?ng-?.*/, /^style$/, /^class$/];
const ngClassRegExp = /^ng-/;
const defaultWrapperComponentOptions = {
    setHostDisplay: false,
};
/**
 * Base class for Angular @Components wrapping React Components.
 * Simplifies some of the handling around passing down props and CSS styling on the host component.
 */
// NOTE: TProps is not used at the moment, but a preparation for a potential future change.
export class ReactWrapperComponent {
    /**
     * Creates an instance of ReactWrapperComponent.
     * @param elementRef The host element.
     * @param changeDetectorRef The change detector for the component.
     * @param renderer The Angular renderer.
     */
    constructor(elementRef, changeDetectorRef, renderer, { setHostDisplay, ngZone } = defaultWrapperComponentOptions) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.renderer = renderer;
        this._ngZone = ngZone;
        this._shouldSetHostDisplay = setHostDisplay;
    }
    /**
     * Alternative to `class` and `[ngClass]` using the same syntax.
     *
     * @description Since this is a wrapper component, sticking to the virtual DOM concept, its DOM element shouldn't have any styling of its own.
     * Instead, any value passes to `contentClass` will be passed to the root component's class as `className`.
     */
    set contentClass(value) {
        this._contentClass = value;
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            this.reactNodeRef.nativeElement.setProperty('className', classnames(value));
            this.markForCheck();
        }
    }
    get contentClass() {
        return this._contentClass;
    }
    /**
     * Alternative to `style` and `[ngStyle]` using (almost) the same syntax.
     * All syntax supports by `ngStyle` is supported, with the exception of specifying units in the key (`{ 'width.px': 12 }`).
     *
     * @description Since this is a wrapper component, sticking to the virtual DOM concept, this should have any styling of its own.
     * Any value passes to `contentStyle` will be passed to the root component's style.
     */
    set contentStyle(value) {
        this._contentStyle = value;
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            const stringValue = typeof value === 'string' ? value : stylenames(value);
            this.reactNodeRef.nativeElement.setProperty('style', toStyle(stringValue));
            this.markForCheck();
        }
    }
    get contentStyle() {
        return this._contentStyle;
    }
    ngAfterContentInit() {
        this._passAttributesAsProps();
    }
    ngAfterViewInit() {
        if (this._shouldSetHostDisplay) {
            this._setHostDisplay();
        }
        // NOTE: Workaround/fix for Issue #5 (https://github.com/Microsoft/angular-react/issues/5).
        // The wrapper component isn't added to the root react nodes list when it's inside a `ReactContent` node, we manually add it (note that the root nodes list is a `Set`, so it won't duplicate nodes if already exist).
        // There's potentially a better solution instead of this
        const rendererData = this.renderer.data;
        if (isReactRendererData(rendererData)) {
            afterRenderFinished(() => {
                const nativeElement = this.reactNodeRef.nativeElement;
                if (isReactNode(nativeElement)) {
                    rendererData.addRootNode(nativeElement);
                }
            });
        }
    }
    ngOnChanges(changes) {
        this._passAttributesAsProps();
        this.markForCheck();
    }
    /**
     * Mark the component as one that needed re-rendering on the React side,
     * and mark for change detection on the Angular side.
     */
    markForCheck() {
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            this.reactNodeRef.nativeElement.setRenderPending();
        }
        this.changeDetectorRef.markForCheck();
    }
    /**
     * Create an JSX renderer for an `@Input` property.
     * @param input The input property.
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    createInputJsxRenderer(input, additionalProps) {
        if (input === undefined) {
            return undefined;
        }
        if (!this._ngZone) {
            throw new Error('To create an input JSX renderer you must pass an NgZone to the constructor.');
        }
        return createInputJsxRenderer(input, this._ngZone, additionalProps);
    }
    /**
     * Create an event handler for a render prop
     * @param renderInputValue the value of the render `@Input` property.
     * @param jsxRenderer an optional renderer to use.
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    createRenderPropHandler(renderInputValue, options) {
        return createRenderPropHandler(renderInputValue, this._ngZone, options);
    }
    _passAttributesAsProps() {
        const hostAttributes = Array.from(this.elementRef.nativeElement.attributes);
        if (!this.reactNodeRef || !isReactNode(this.reactNodeRef.nativeElement)) {
            throw new Error('reactNodeRef must hold a reference to a ReactNode');
        }
        // Ensure there are no blacklisted props. Suggest alternative as error if there is any
        hostAttributes.forEach(attr => {
            const [forbidden, alternativeAttrName] = this._isForbiddenAttribute(attr);
            if (forbidden) {
                throw new Error(`[${this.elementRef
                    .nativeElement.tagName.toLowerCase()}] React wrapper components cannot have the '${attr.name}' attribute set. Use the following alternative: ${alternativeAttrName || ''}`);
            }
        });
        const whitelistedHostAttributes = hostAttributes.filter(attr => !this._isIgnoredAttribute(attr));
        const props = whitelistedHostAttributes.reduce((acc, attr) => ({
            ...acc,
            [attr.name]: attr.value,
        }), {});
        const eventListeners = this.elementRef.nativeElement.getEventListeners?.();
        const eventHandlersProps = eventListeners && Object.keys(eventListeners).length
            ? toObject(Object.values(eventListeners).map(([eventListener]) => [
                eventListener.type,
                (ev) => eventListener.listener(ev && ev.nativeEvent),
            ]))
            : {};
        {
        }
        this.reactNodeRef.nativeElement.setProperties({ ...props, ...eventHandlersProps });
    }
    _setHostDisplay() {
        const nativeElement = this.elementRef.nativeElement;
        // We want to wait until child elements are rendered
        requestAnimationFrame(() => {
            if (nativeElement.firstElementChild) {
                const rootChildDisplay = getComputedStyle(nativeElement.firstElementChild).display;
                nativeElement.style.display = rootChildDisplay;
            }
        });
    }
    _isIgnoredAttribute(attr) {
        return ignoredAttributeMatchers.some(regExp => regExp.test(attr.name));
    }
    _isForbiddenAttribute(attr) {
        const { name, value } = attr;
        if (name === 'key')
            return [true, undefined];
        if (name === 'class' && value.split(' ').some(className => !ngClassRegExp.test(className)))
            return [true, 'contentClass'];
        if (name === 'style') {
            const style = toStyle(value);
            // Only allowing style if it's something that changes the display - setting anything else should be done on the child component directly (via the `styles` attribute in fabric for example)
            if (Object.entries(style).filter(([key, value]) => value && key !== 'display').length > 0) {
                return [true, 'contentStyle'];
            }
        }
        return [false, undefined];
    }
}
/** @nocollapse */ ReactWrapperComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: ReactWrapperComponent, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ ReactWrapperComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: ReactWrapperComponent, inputs: { contentClass: "contentClass", contentStyle: "contentStyle" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: ReactWrapperComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: undefined }]; }, propDecorators: { contentClass: [{
                type: Input
            }], contentStyle: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid3JhcHBlci1jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL2NvcmUvc3JjL2xpYi9jb21wb25lbnRzL3dyYXBwZXItY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLHlEQUF5RDtBQUZ6RCw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDLHlEQUF5RDtBQUV6RCxPQUFPLEVBQWdELEtBQUssRUFBaUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzlKLE9BQU8sVUFBVSxNQUFNLFlBQVksQ0FBQztBQUNwQyxPQUFPLE9BQU8sTUFBTSxjQUFjLENBQUM7QUFDbkMsT0FBTyxVQUEyQixNQUFNLFlBQVksQ0FBQztBQUlyRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDckQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ25FLE9BQU8sRUFBdUMsc0JBQXNCLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7QUFFdEgsdUtBQXVLO0FBQ3ZLLE1BQU0sd0JBQXdCLEdBQUcsQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBRXJFLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQztBQXNCN0IsTUFBTSw4QkFBOEIsR0FBNEI7SUFDOUQsY0FBYyxFQUFFLEtBQUs7Q0FDdEIsQ0FBQztBQUVGOzs7R0FHRztBQUNILDJGQUEyRjtBQUUzRixNQUFNLE9BQWdCLHFCQUFxQjtJQWlEekM7Ozs7O09BS0c7SUFDSCxZQUNrQixVQUFtQyxFQUNsQyxpQkFBb0MsRUFDcEMsUUFBbUIsRUFDcEMsRUFBRSxjQUFjLEVBQUUsTUFBTSxLQUE4Qiw4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QUFTLENBQUMsQ0FBQztJQUM1QixDQUFDOztxSUExTm1CLHFCQUFxQjt5SEFBckIscUJBQXFCOzJGQUFyQixxQkFBcUI7a0JBRDFDLFNBQVM7OEtBaUJKLFlBQVk7c0JBRGYsS0FBSztnQkFxQkYsWUFBWTtzQkFEZixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0B0eXBlcy9nZXRldmVudGxpc3RlbmVycy5kLnRzXCIgLz5cclxuXHJcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBJbnB1dCwgTmdab25lLCBPbkNoYW5nZXMsIFJlbmRlcmVyMiwgU2ltcGxlQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCwgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgdG9TdHlsZSBmcm9tICdjc3MtdG8tc3R5bGUnO1xyXG5pbXBvcnQgc3R5bGVuYW1lcywgeyBTdHlsZU9iamVjdCB9IGZyb20gJ3N0eWxlbmFtZXMnO1xyXG5cclxuaW1wb3J0IHsgTWFueSB9IGZyb20gJy4uL2RlY2xhcmF0aW9ucy9tYW55JztcclxuaW1wb3J0IHsgUmVhY3RDb250ZW50UHJvcHMgfSBmcm9tICcuLi9yZW5kZXJlci9yZWFjdC1jb250ZW50JztcclxuaW1wb3J0IHsgaXNSZWFjdE5vZGUgfSBmcm9tICcuLi9yZW5kZXJlci9yZWFjdC1ub2RlJztcclxuaW1wb3J0IHsgaXNSZWFjdFJlbmRlcmVyRGF0YSB9IGZyb20gJy4uL3JlbmRlcmVyL3JlbmRlcmVyJztcclxuaW1wb3J0IHsgdG9PYmplY3QgfSBmcm9tICcuLi91dGlscy9vYmplY3QvdG8tb2JqZWN0JztcclxuaW1wb3J0IHsgYWZ0ZXJSZW5kZXJGaW5pc2hlZCB9IGZyb20gJy4uL3V0aWxzL3JlbmRlci9yZW5kZXItZGVsYXknO1xyXG5pbXBvcnQgeyBJbnB1dFJlbmRlcmVyT3B0aW9ucywgSnN4UmVuZGVyRnVuYywgY3JlYXRlSW5wdXRKc3hSZW5kZXJlciwgY3JlYXRlUmVuZGVyUHJvcEhhbmRsZXIgfSBmcm9tICcuL3JlbmRlci1wcm9wcyc7XHJcblxyXG4vLyBGb3JiaWRkZW4gYXR0cmlidXRlcyBhcmUgc3RpbGwgaWdub3JlZCwgc2luY2UgdGhleSBtYXkgYmUgc2V0IGZyb20gdGhlIHdyYXBwZXIgY29tcG9uZW50cyB0aGVtc2VsdmVzIChmb3JiaWRkZW4gaXMgb25seSBhcHBsaWVkIGZvciB1c2VycyBvZiB0aGUgd3JhcHBlciBjb21wb25lbnRzKVxyXG5jb25zdCBpZ25vcmVkQXR0cmlidXRlTWF0Y2hlcnMgPSBbL15fP25nLT8uKi8sIC9ec3R5bGUkLywgL15jbGFzcyQvXTtcclxuXHJcbmNvbnN0IG5nQ2xhc3NSZWdFeHAgPSAvXm5nLS87XHJcblxyXG5leHBvcnQgdHlwZSBDb250ZW50Q2xhc3NWYWx1ZSA9IHN0cmluZ1tdIHwgU2V0PHN0cmluZz4gfCB7IFtrbGFzczogc3RyaW5nXTogYW55IH07XHJcbmV4cG9ydCB0eXBlIENvbnRlbnRTdHlsZVZhbHVlID0gc3RyaW5nIHwgU3R5bGVPYmplY3Q7XHJcblxyXG4vKipcclxuICogT3B0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIGBSZWFjdFdyYXBwZXJDb21wb25lbnRgLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBXcmFwcGVyQ29tcG9uZW50T3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgaG9zdCdzIGBkaXNwbGF5YCBzaG91bGQgYmUgc2V0IHRvIHRoZSByb290IGNoaWxkIG5vZGUnc2BkaXNwbGF5YC5cclxuICAgKiBAZGVmYXVsdCBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHNldEhvc3REaXNwbGF5PzogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHpvbmUgdG8gdXNlIHRvIHRyYWNrIGNoYW5nZXMgdG8gaW5uZXIgKEFuZ3VsYXIpIHRlbXBsYXRlcyAmIGNvbXBvbmVudHMuXHJcbiAgICogQGRlZmF1bHQgYHVuZGVmaW5lZGAuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgbmdab25lPzogTmdab25lO1xyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0V3JhcHBlckNvbXBvbmVudE9wdGlvbnM6IFdyYXBwZXJDb21wb25lbnRPcHRpb25zID0ge1xyXG4gIHNldEhvc3REaXNwbGF5OiBmYWxzZSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBBbmd1bGFyIEBDb21wb25lbnRzIHdyYXBwaW5nIFJlYWN0IENvbXBvbmVudHMuXHJcbiAqIFNpbXBsaWZpZXMgc29tZSBvZiB0aGUgaGFuZGxpbmcgYXJvdW5kIHBhc3NpbmcgZG93biBwcm9wcyBhbmQgQ1NTIHN0eWxpbmcgb24gdGhlIGhvc3QgY29tcG9uZW50LlxyXG4gKi9cclxuLy8gTk9URTogVFByb3BzIGlzIG5vdCB1c2VkIGF0IHRoZSBtb21lbnQsIGJ1dCBhIHByZXBhcmF0aW9uIGZvciBhIHBvdGVudGlhbCBmdXR1cmUgY2hhbmdlLlxyXG5ARGlyZWN0aXZlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlYWN0V3JhcHBlckNvbXBvbmVudDxUUHJvcHMgZXh0ZW5kcyB7fT4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMge1xyXG4gIHByaXZhdGUgX2NvbnRlbnRDbGFzczogTWFueTxDb250ZW50Q2xhc3NWYWx1ZT47XHJcbiAgcHJpdmF0ZSBfY29udGVudFN0eWxlOiBDb250ZW50U3R5bGVWYWx1ZTtcclxuXHJcbiAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmU7XHJcbiAgcHJpdmF0ZSBfc2hvdWxkU2V0SG9zdERpc3BsYXk6IGJvb2xlYW47XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFjdE5vZGVSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xyXG5cclxuICAvKipcclxuICAgKiBBbHRlcm5hdGl2ZSB0byBgY2xhc3NgIGFuZCBgW25nQ2xhc3NdYCB1c2luZyB0aGUgc2FtZSBzeW50YXguXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb24gU2luY2UgdGhpcyBpcyBhIHdyYXBwZXIgY29tcG9uZW50LCBzdGlja2luZyB0byB0aGUgdmlydHVhbCBET00gY29uY2VwdCwgaXRzIERPTSBlbGVtZW50IHNob3VsZG4ndCBoYXZlIGFueSBzdHlsaW5nIG9mIGl0cyBvd24uXHJcbiAgICogSW5zdGVhZCwgYW55IHZhbHVlIHBhc3NlcyB0byBgY29udGVudENsYXNzYCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgcm9vdCBjb21wb25lbnQncyBjbGFzcyBhcyBgY2xhc3NOYW1lYC5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIHNldCBjb250ZW50Q2xhc3ModmFsdWU6IE1hbnk8Q29udGVudENsYXNzVmFsdWU+KSB7XHJcbiAgICB0aGlzLl9jb250ZW50Q2xhc3MgPSB2YWx1ZTtcclxuICAgIGlmIChpc1JlYWN0Tm9kZSh0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50KSkge1xyXG4gICAgICB0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50LnNldFByb3BlcnR5KCdjbGFzc05hbWUnLCBjbGFzc25hbWVzKHZhbHVlKSk7XHJcbiAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudENsYXNzKCk6IE1hbnk8Q29udGVudENsYXNzVmFsdWU+IHtcclxuICAgIHJldHVybiB0aGlzLl9jb250ZW50Q2xhc3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbHRlcm5hdGl2ZSB0byBgc3R5bGVgIGFuZCBgW25nU3R5bGVdYCB1c2luZyAoYWxtb3N0KSB0aGUgc2FtZSBzeW50YXguXHJcbiAgICogQWxsIHN5bnRheCBzdXBwb3J0cyBieSBgbmdTdHlsZWAgaXMgc3VwcG9ydGVkLCB3aXRoIHRoZSBleGNlcHRpb24gb2Ygc3BlY2lmeWluZyB1bml0cyBpbiB0aGUga2V5IChgeyAnd2lkdGgucHgnOiAxMiB9YCkuXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb24gU2luY2UgdGhpcyBpcyBhIHdyYXBwZXIgY29tcG9uZW50LCBzdGlja2luZyB0byB0aGUgdmlydHVhbCBET00gY29uY2VwdCwgdGhpcyBzaG91bGQgaGF2ZSBhbnkgc3R5bGluZyBvZiBpdHMgb3duLlxyXG4gICAqIEFueSB2YWx1ZSBwYXNzZXMgdG8gYGNvbnRlbnRTdHlsZWAgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHJvb3QgY29tcG9uZW50J3Mgc3R5bGUuXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBzZXQgY29udGVudFN0eWxlKHZhbHVlOiBDb250ZW50U3R5bGVWYWx1ZSkge1xyXG4gICAgdGhpcy5fY29udGVudFN0eWxlID0gdmFsdWU7XHJcbiAgICBpZiAoaXNSZWFjdE5vZGUodGhpcy5yZWFjdE5vZGVSZWYubmF0aXZlRWxlbWVudCkpIHtcclxuICAgICAgY29uc3Qgc3RyaW5nVmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBzdHlsZW5hbWVzKHZhbHVlKTtcclxuICAgICAgdGhpcy5yZWFjdE5vZGVSZWYubmF0aXZlRWxlbWVudC5zZXRQcm9wZXJ0eSgnc3R5bGUnLCB0b1N0eWxlKHN0cmluZ1ZhbHVlKSk7XHJcbiAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudFN0eWxlKCk6IENvbnRlbnRTdHlsZVZhbHVlIHtcclxuICAgIHJldHVybiB0aGlzLl9jb250ZW50U3R5bGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlYWN0V3JhcHBlckNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gZWxlbWVudFJlZiBUaGUgaG9zdCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSBjaGFuZ2VEZXRlY3RvclJlZiBUaGUgY2hhbmdlIGRldGVjdG9yIGZvciB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSByZW5kZXJlciBUaGUgQW5ndWxhciByZW5kZXJlci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSByZW5kZXJlcjogUmVuZGVyZXIyLFxyXG4gICAgeyBzZXRIb3N0RGlzcGxheSwgbmdab25lIH06IFdyYXBwZXJDb21wb25lbnRPcHRpb25zID0gZGVmYXVsdFdyYXBwZXJDb21wb25lbnRPcHRpb25zXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9uZ1pvbmUgPSBuZ1pvbmU7XHJcbiAgICB0aGlzLl9zaG91bGRTZXRIb3N0RGlzcGxheSA9IHNldEhvc3REaXNwbGF5O1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgdGhpcy5fcGFzc0F0dHJpYnV0ZXNBc1Byb3BzKCk7XHJcbiAgfVxyXG5cclxuICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICBpZiAodGhpcy5fc2hvdWxkU2V0SG9zdERpc3BsYXkpIHtcclxuICAgICAgdGhpcy5fc2V0SG9zdERpc3BsYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOT1RFOiBXb3JrYXJvdW5kL2ZpeCBmb3IgSXNzdWUgIzUgKGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvYW5ndWxhci1yZWFjdC9pc3N1ZXMvNSkuXHJcbiAgICAvLyBUaGUgd3JhcHBlciBjb21wb25lbnQgaXNuJ3QgYWRkZWQgdG8gdGhlIHJvb3QgcmVhY3Qgbm9kZXMgbGlzdCB3aGVuIGl0J3MgaW5zaWRlIGEgYFJlYWN0Q29udGVudGAgbm9kZSwgd2UgbWFudWFsbHkgYWRkIGl0IChub3RlIHRoYXQgdGhlIHJvb3Qgbm9kZXMgbGlzdCBpcyBhIGBTZXRgLCBzbyBpdCB3b24ndCBkdXBsaWNhdGUgbm9kZXMgaWYgYWxyZWFkeSBleGlzdCkuXHJcbiAgICAvLyBUaGVyZSdzIHBvdGVudGlhbGx5IGEgYmV0dGVyIHNvbHV0aW9uIGluc3RlYWQgb2YgdGhpc1xyXG4gICAgY29uc3QgcmVuZGVyZXJEYXRhID0gdGhpcy5yZW5kZXJlci5kYXRhO1xyXG4gICAgaWYgKGlzUmVhY3RSZW5kZXJlckRhdGEocmVuZGVyZXJEYXRhKSkge1xyXG4gICAgICBhZnRlclJlbmRlckZpbmlzaGVkKCgpID0+IHtcclxuICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5yZWFjdE5vZGVSZWYubmF0aXZlRWxlbWVudDtcclxuICAgICAgICBpZiAoaXNSZWFjdE5vZGUobmF0aXZlRWxlbWVudCkpIHtcclxuICAgICAgICAgIHJlbmRlcmVyRGF0YS5hZGRSb290Tm9kZShuYXRpdmVFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgdGhpcy5fcGFzc0F0dHJpYnV0ZXNBc1Byb3BzKCk7XHJcblxyXG4gICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBvbmUgdGhhdCBuZWVkZWQgcmUtcmVuZGVyaW5nIG9uIHRoZSBSZWFjdCBzaWRlLFxyXG4gICAqIGFuZCBtYXJrIGZvciBjaGFuZ2UgZGV0ZWN0aW9uIG9uIHRoZSBBbmd1bGFyIHNpZGUuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG1hcmtGb3JDaGVjaygpIHtcclxuICAgIGlmIChpc1JlYWN0Tm9kZSh0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50KSkge1xyXG4gICAgICB0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50LnNldFJlbmRlclBlbmRpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIEpTWCByZW5kZXJlciBmb3IgYW4gYEBJbnB1dGAgcHJvcGVydHkuXHJcbiAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBwcm9wZXJ0eS5cclxuICAgKiBAcGFyYW0gYWRkaXRpb25hbFByb3BzIG9wdGlvbmFsIGFkZGl0aW9uYWwgcHJvcHMgdG8gcGFzcyB0byB0aGUgYFJlYWN0Q29udGVudGAgb2JqZWN0IHRoYXQgd2lsbCByZW5kZXIgdGhlIGNvbnRlbnQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGNyZWF0ZUlucHV0SnN4UmVuZGVyZXI8VENvbnRleHQgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gICAgaW5wdXQ6IElucHV0UmVuZGVyZXJPcHRpb25zPFRDb250ZXh0PixcclxuICAgIGFkZGl0aW9uYWxQcm9wcz86IFJlYWN0Q29udGVudFByb3BzXHJcbiAgKTogSnN4UmVuZGVyRnVuYzxUQ29udGV4dD4gfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX25nWm9uZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIGNyZWF0ZSBhbiBpbnB1dCBKU1ggcmVuZGVyZXIgeW91IG11c3QgcGFzcyBhbiBOZ1pvbmUgdG8gdGhlIGNvbnN0cnVjdG9yLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjcmVhdGVJbnB1dEpzeFJlbmRlcmVyKGlucHV0LCB0aGlzLl9uZ1pvbmUsIGFkZGl0aW9uYWxQcm9wcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3IgYSByZW5kZXIgcHJvcFxyXG4gICAqIEBwYXJhbSByZW5kZXJJbnB1dFZhbHVlIHRoZSB2YWx1ZSBvZiB0aGUgcmVuZGVyIGBASW5wdXRgIHByb3BlcnR5LlxyXG4gICAqIEBwYXJhbSBqc3hSZW5kZXJlciBhbiBvcHRpb25hbCByZW5kZXJlciB0byB1c2UuXHJcbiAgICogQHBhcmFtIGFkZGl0aW9uYWxQcm9wcyBvcHRpb25hbCBhZGRpdGlvbmFsIHByb3BzIHRvIHBhc3MgdG8gdGhlIGBSZWFjdENvbnRlbnRgIG9iamVjdCB0aGF0IHdpbGwgcmVuZGVyIHRoZSBjb250ZW50LlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBjcmVhdGVSZW5kZXJQcm9wSGFuZGxlcjxUUmVuZGVyUHJvcHMgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gICAgcmVuZGVySW5wdXRWYWx1ZTogSW5wdXRSZW5kZXJlck9wdGlvbnM8VFJlbmRlclByb3BzPixcclxuICAgIG9wdGlvbnM/OiB7XHJcbiAgICAgIGpzeFJlbmRlcmVyPzogSnN4UmVuZGVyRnVuYzxUUmVuZGVyUHJvcHM+O1xyXG4gICAgICBhZGRpdGlvbmFsUHJvcHM/OiBSZWFjdENvbnRlbnRQcm9wcztcclxuICAgIH1cclxuICApOiAocHJvcHM/OiBUUmVuZGVyUHJvcHMsIGRlZmF1bHRSZW5kZXI/OiBKc3hSZW5kZXJGdW5jPFRSZW5kZXJQcm9wcz4pID0+IEpTWC5FbGVtZW50IHwgbnVsbCB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVuZGVyUHJvcEhhbmRsZXIocmVuZGVySW5wdXRWYWx1ZSwgdGhpcy5fbmdab25lLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3Bhc3NBdHRyaWJ1dGVzQXNQcm9wcygpIHtcclxuICAgIGNvbnN0IGhvc3RBdHRyaWJ1dGVzID0gQXJyYXkuZnJvbSgodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmF0dHJpYnV0ZXMpO1xyXG5cclxuICAgIGlmICghdGhpcy5yZWFjdE5vZGVSZWYgfHwgIWlzUmVhY3ROb2RlKHRoaXMucmVhY3ROb2RlUmVmLm5hdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVhY3ROb2RlUmVmIG11c3QgaG9sZCBhIHJlZmVyZW5jZSB0byBhIFJlYWN0Tm9kZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVuc3VyZSB0aGVyZSBhcmUgbm8gYmxhY2tsaXN0ZWQgcHJvcHMuIFN1Z2dlc3QgYWx0ZXJuYXRpdmUgYXMgZXJyb3IgaWYgdGhlcmUgaXMgYW55XHJcbiAgICBob3N0QXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xyXG4gICAgICBjb25zdCBbZm9yYmlkZGVuLCBhbHRlcm5hdGl2ZUF0dHJOYW1lXSA9IHRoaXMuX2lzRm9yYmlkZGVuQXR0cmlidXRlKGF0dHIpO1xyXG4gICAgICBpZiAoZm9yYmlkZGVuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYFskeyh0aGlzLmVsZW1lbnRSZWZcclxuICAgICAgICAgICAgLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLnRhZ05hbWUudG9Mb3dlckNhc2UoKX1dIFJlYWN0IHdyYXBwZXIgY29tcG9uZW50cyBjYW5ub3QgaGF2ZSB0aGUgJyR7XHJcbiAgICAgICAgICAgIGF0dHIubmFtZVxyXG4gICAgICAgICAgfScgYXR0cmlidXRlIHNldC4gVXNlIHRoZSBmb2xsb3dpbmcgYWx0ZXJuYXRpdmU6ICR7YWx0ZXJuYXRpdmVBdHRyTmFtZSB8fCAnJ31gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgd2hpdGVsaXN0ZWRIb3N0QXR0cmlidXRlcyA9IGhvc3RBdHRyaWJ1dGVzLmZpbHRlcihhdHRyID0+ICF0aGlzLl9pc0lnbm9yZWRBdHRyaWJ1dGUoYXR0cikpO1xyXG4gICAgY29uc3QgcHJvcHMgPSB3aGl0ZWxpc3RlZEhvc3RBdHRyaWJ1dGVzLnJlZHVjZShcclxuICAgICAgKGFjYywgYXR0cikgPT4gKHtcclxuICAgICAgICAuLi5hY2MsXHJcbiAgICAgICAgW2F0dHIubmFtZV06IGF0dHIudmFsdWUsXHJcbiAgICAgIH0pLFxyXG4gICAgICB7fVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEV2ZW50TGlzdGVuZXJzPy4oKTtcclxuICAgIGNvbnN0IGV2ZW50SGFuZGxlcnNQcm9wcyA9XHJcbiAgICAgIGV2ZW50TGlzdGVuZXJzICYmIE9iamVjdC5rZXlzKGV2ZW50TGlzdGVuZXJzKS5sZW5ndGhcclxuICAgICAgICA/IHRvT2JqZWN0KFxyXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGV2ZW50TGlzdGVuZXJzKS5tYXA8W3N0cmluZywgUmVhY3QuRXZlbnRIYW5kbGVyPFJlYWN0LlN5bnRoZXRpY0V2ZW50Pl0+KChbZXZlbnRMaXN0ZW5lcl0pID0+IFtcclxuICAgICAgICAgICAgICBldmVudExpc3RlbmVyLnR5cGUsXHJcbiAgICAgICAgICAgICAgKGV2OiBSZWFjdC5TeW50aGV0aWNFdmVudCkgPT4gZXZlbnRMaXN0ZW5lci5saXN0ZW5lcihldiAmJiBldi5uYXRpdmVFdmVudCksXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgOiB7fTtcclxuICAgIHtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50LnNldFByb3BlcnRpZXMoeyAuLi5wcm9wcywgLi4uZXZlbnRIYW5kbGVyc1Byb3BzIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc2V0SG9zdERpc3BsYXkoKSB7XHJcbiAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XHJcblxyXG4gICAgLy8gV2Ugd2FudCB0byB3YWl0IHVudGlsIGNoaWxkIGVsZW1lbnRzIGFyZSByZW5kZXJlZFxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgaWYgKG5hdGl2ZUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpIHtcclxuICAgICAgICBjb25zdCByb290Q2hpbGREaXNwbGF5ID0gZ2V0Q29tcHV0ZWRTdHlsZShuYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKS5kaXNwbGF5O1xyXG4gICAgICAgIG5hdGl2ZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHJvb3RDaGlsZERpc3BsYXk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfaXNJZ25vcmVkQXR0cmlidXRlKGF0dHI6IEF0dHIpIHtcclxuICAgIHJldHVybiBpZ25vcmVkQXR0cmlidXRlTWF0Y2hlcnMuc29tZShyZWdFeHAgPT4gcmVnRXhwLnRlc3QoYXR0ci5uYW1lKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9pc0ZvcmJpZGRlbkF0dHJpYnV0ZShhdHRyOiBBdHRyKTogW2Jvb2xlYW4sIHN0cmluZyB8IHVuZGVmaW5lZF0ge1xyXG4gICAgY29uc3QgeyBuYW1lLCB2YWx1ZSB9ID0gYXR0cjtcclxuXHJcbiAgICBpZiAobmFtZSA9PT0gJ2tleScpIHJldHVybiBbdHJ1ZSwgdW5kZWZpbmVkXTtcclxuICAgIGlmIChuYW1lID09PSAnY2xhc3MnICYmIHZhbHVlLnNwbGl0KCcgJykuc29tZShjbGFzc05hbWUgPT4gIW5nQ2xhc3NSZWdFeHAudGVzdChjbGFzc05hbWUpKSlcclxuICAgICAgcmV0dXJuIFt0cnVlLCAnY29udGVudENsYXNzJ107XHJcbiAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICBjb25zdCBzdHlsZSA9IHRvU3R5bGUodmFsdWUpO1xyXG4gICAgICAvLyBPbmx5IGFsbG93aW5nIHN0eWxlIGlmIGl0J3Mgc29tZXRoaW5nIHRoYXQgY2hhbmdlcyB0aGUgZGlzcGxheSAtIHNldHRpbmcgYW55dGhpbmcgZWxzZSBzaG91bGQgYmUgZG9uZSBvbiB0aGUgY2hpbGQgY29tcG9uZW50IGRpcmVjdGx5ICh2aWEgdGhlIGBzdHlsZXNgIGF0dHJpYnV0ZSBpbiBmYWJyaWMgZm9yIGV4YW1wbGUpXHJcbiAgICAgIGlmIChPYmplY3QuZW50cmllcyhzdHlsZSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICYmIGtleSAhPT0gJ2Rpc3BsYXknKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0cnVlLCAnY29udGVudFN0eWxlJ107XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2ZhbHNlLCB1bmRlZmluZWRdO1xyXG4gIH1cclxufVxyXG4iXX0=