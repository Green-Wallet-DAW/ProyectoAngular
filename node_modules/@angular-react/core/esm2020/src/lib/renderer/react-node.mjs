// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import removeUndefinedProperties from '../utils/object/remove-undefined-properties';
import { CHILDREN_TO_APPEND_PROP } from './react-content';
import { getComponentClass } from './registry';
const DEBUG = false;
export function isReactNode(node) {
    return node.setRenderPendingCallback !== undefined;
}
/**
 * Logical representation of everything needed to render a React element in the
 * DOM, with the needed methods to do so.
 */
export class ReactNode {
    constructor(type) {
        this.type = type;
        // Access to these properties are restricted through setters and functions
        // so that the dirty "render pending" state of this object can be properly
        // tracked and all nodes with "render pending" can be flushed at the end
        // of a render operation.
        this._props = {};
        this._children = [];
        this._childrenToAppend = [];
        this._isDestroyPending = false;
        this._isRenderPending = true;
        this.setRenderPendingCallback = () => null;
        this.setRenderPending();
        this._tryResolveTypeIsReactElementClass();
    }
    get domElement() {
        return this._renderedDomElement;
    }
    set parent(parent) {
        this._parent = parent;
        this.setRenderPending();
    }
    get parent() {
        return this._parent;
    }
    get shouldRender() {
        return !this._isNotRenderable;
    }
    get destroyPending() {
        return this._isDestroyPending;
    }
    /**
     * Track all pending render operations internally and set flag on
     * renderer factory so that a flush operation can be scheduled for
     * the "end" of render.
     */
    setRenderPending() {
        this.setRenderPendingCallback();
        this._isRenderPending = true;
    }
    /**
     * Marks the node to be removed from the DOM in the next render cycle.
     */
    destroyNode() {
        this.setRenderPending();
        this._isDestroyPending = true;
    }
    /**
     * Sets an attribute on the node.
     * @note the value can only be a `string`. See `setProperty` for other use-cases.
     * @see `Renderer2#setAttribute`.
     *
     * @param name The attribute name.
     * @param value The new value.
     */
    setAttribute(name, value) {
        this.setAttributes({ [name]: value });
    }
    /**
     * Set attributes on this node.
     * Note that values can only be of type `string`. See `setProperties` for other use-cases.
     * @see `Renderer2#setAttribute`.
     *
     * @param attributes the attributes to set.
     */
    setAttributes(attributes) {
        this.setProperties(attributes);
    }
    /**
     * Sets a prop in the underlying React element.
     * @see `Renderer2#setProperty`.
     *
     * @param name The property name.
     * @param value The new value.
     */
    setProperty(name, value) {
        this.setProperties({ [name]: value });
    }
    /**
     * Like `setProperty` but for multiple props at once.
     *
     * @param properties An object with the props.
     */
    setProperties(properties) {
        this.setRenderPending();
        Object.assign(this._props, removeUndefinedProperties(properties));
    }
    /**
     * Remove a prop or an attribute from the underlying React element.
     * @see `Renderer2#removeAttribute`.
     *
     * @param name The property name.
     * @param childName _Optional_ A property of `name` to remove instead.
     * @returns the deleted property
     */
    removeProperty(name, childName) {
        this.setRenderPending();
        if (childName) {
            return delete this._props[name][childName];
        }
        return delete this._props[name];
    }
    /**
     * Add a direct child of this node.
     * @see `Renderer2#addChild`.
     *
     * @param node The node to add.
     */
    addChild(node) {
        this.setRenderPending();
        this._children.push(node);
    }
    /**
     * Remove a direct child of this node.
     * @see `Renderer2#removeChild`.
     *
     * @param node The node to remove.
     */
    removeChild(node) {
        this.setRenderPending();
        this._children = this._children.filter(child => child !== node);
    }
    /**
     * Cast the node to a comment node.
     * @see `Renderer2#createComment`.
     *
     * @param value the text in the comment to render.
     * @returns itself.
     */
    asComment(value) {
        this.setRenderPending();
        this.type = undefined;
        this._comment = value;
        return this;
    }
    /**
     * Cast the node to a text node.
     * @see `Renderer2#createText`.
     *
     * @param value the text to render.
     * @returns itself.
     */
    asText(value) {
        this.setRenderPending();
        this.type = undefined;
        this._text = value;
        // Skip appending and rendering of empty text nodes. This may cause a bug
        // if a single space is desired...
        if (!value || !value.trim()) {
            this._isNotRenderable = true;
        }
        return this;
    }
    /**
     * Render the node to the DOM, or unmount it, as necessary.
     *
     * @returns itself.
     */
    render() {
        // Only complete render operations for ReactNodes that are parented by HTMLElements.
        // Those that are parented by other ReactNodes will be rendered recursively by their
        // parent.
        if (!isReactNode(this._parent)) {
            if (this._isDestroyPending && this._parent) {
                if (DEBUG) {
                    console.log('ReactNode > render > destroy > node:', this.toString(), 'parent:', this.parent);
                }
                ReactDOM.unmountComponentAtNode(this._parent);
                return this;
            }
            if (this._isRenderPending) {
                if (DEBUG) {
                    console.log('ReactNode > render > node:', this.toString(), 'parent:', this.parent);
                }
                // It is expected that the element will be recreated and re-rendered with each attribute change.
                // See: https://reactjs.org/docs/rendering-elements.html
                ReactDOM.render(this._renderRecursive(), this._parent);
                this._isRenderPending = false;
            }
        }
        return this;
    }
    /**
     * Appends a child.
     *
     * @see `Renderer2#appendChild`.
     * @note This is called by Angular core when projected content is being added.
     *
     * @param projectedContent the content to project.
     */
    appendChild(projectedContent) {
        if (DEBUG) {
            console.error('ReactNode > appendChild > node:', this.toString(), 'projectedContent:', projectedContent.toString().trim());
        }
        this._childrenToAppend.push(projectedContent);
    }
    /**
     * @note for easier debugging.
     */
    toString() {
        if (this._typeName) {
            return `[${this._typeName} ReactNode]`;
        }
        if (this._text) {
            return '[text ReactNode]';
        }
        if (this._comment) {
            return '[comment ReactNode]';
        }
        return '[undefined ReactNode]';
    }
    _renderRecursive(key) {
        const children = this._children
            ? this._children.map((child, index) => child._renderRecursive(index.toString()))
            : [];
        if (this._text) {
            return this._text;
        }
        this._props[CHILDREN_TO_APPEND_PROP] = this._childrenToAppend;
        if (key) {
            this._props['key'] = key;
        }
        // Just having some props on a React element can cause it to
        // behave undesirably, and since the templates are hard-coded to pass
        // all Inputs all the time, they pass `undefined` values too.
        // This ensures these are removed.
        // Additionally, there are some things that Angular templating forbids,
        // and stops at-compile time (with errors), such as `Input`s being prefixed with `on`.
        // Since React does not have the notion of `Output`s as Angular (they are just props of type function, essentially callbacks).
        // To work around this, we, by convention, prefix any PascalCased prop with `on` here, after the template has already been compiled.
        const clearedProps = this._transformProps(removeUndefinedProperties(this._props));
        if (DEBUG) {
            console.warn('ReactNode > renderRecursive > type:', this.toString(), 'props:', this._props, 'children:', children);
        }
        return React.createElement(this.type, clearedProps, children.length > 0 ? children : undefined);
    }
    _transformProps(props) {
        return Object.entries(props).reduce((acc, [key, value]) => {
            const [newKey, newValue] = typeof key !== 'string' ? [key, value] : this._transformProp(key, value);
            return Object.assign(acc, { [newKey]: newValue });
        }, {});
    }
    _transformProp(name, value) {
        // prop name is camelCased already
        const firstLetter = name[0];
        if (firstLetter === firstLetter.toLowerCase()) {
            return [name, value];
        }
        // prop name is PascalCased & is a function - assuming render prop or callback prop that has return value
        // NOTE: Angular doesn't allow passing @Inputs that are prefixed with "on". This is useful for render props and properties representing the "on" state (for example, Toggle).
        // As a convention, any @Input that starts with a capital letter is prefixed with "on" when passed as a prop to the underlying React component.
        return [`on${name}`, value];
    }
    _tryResolveTypeIsReactElementClass() {
        if (this._typeIsReactElementClass === undefined) {
            // Comments and text have no type.
            if (!this.type) {
                return;
            }
            // Store the name of the type for the toString message (debugging).
            this._typeName = this.type;
            // Attempt to resolve the type as a React Element class name/type.
            // Since Angular templates are just strings, we can't include types in them.
            // Therefore, we use the component registry to resolve the type of a component from a string.
            if (typeof this.type === 'string') {
                this.type = getComponentClass(this.type);
            }
            // If type is still a string, then no React Element matches this string.
            this._typeIsReactElementClass = typeof this.type !== 'string';
            if (DEBUG) {
                console.log('ReactNode > tryResolveTypeIsReactElementClass > type:', this._typeName);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3Qtbm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY29yZS9zcmMvbGliL3JlbmRlcmVyL3JlYWN0LW5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNERBQTREO0FBQzVELGtDQUFrQztBQUVsQyxPQUFPLEtBQUssS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMvQixPQUFPLEtBQUssUUFBUSxNQUFNLFdBQVcsQ0FBQztBQUd0QyxPQUFPLHlCQUF5QixNQUFNLDZDQUE2QyxDQUFDO0FBQ3BGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzFELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUUvQyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUM7QUFFcEIsTUFBTSxVQUFVLFdBQVcsQ0FBQyxJQUFTO0lBQ25DLE9BQW1CLElBQUssQ0FBQyx3QkFBd0IsS0FBSyxTQUFTLENBQUM7QUFDbEUsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sT0FBTyxTQUFTO0lBdUNwQixZQUFvQixJQUErQjtRQUEvQixTQUFJLEdBQUosSUFBSSxDQUEyQjtRQXRDbkQsMEVBQTBFO1FBQzFFLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUseUJBQXlCO1FBQ2pCLFdBQU0sR0FBRyxFQUFFLENBQUM7UUFJWixjQUFTLEdBQXFCLEVBQUUsQ0FBQztRQUVqQyxzQkFBaUIsR0FBOEIsRUFBRSxDQUFDO1FBSWxELHNCQUFpQixHQUFZLEtBQUssQ0FBQztRQUNuQyxxQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUE0QmhDLDZCQUF3QixHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQztRQUpwQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsa0NBQWtDLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBeEJELElBQUksVUFBVTtRQUNaLE9BQU8s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TWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XHJcblxyXG5pbXBvcnQgeyBTdHJpbmdNYXAgfSBmcm9tICcuLi9kZWNsYXJhdGlvbnMvc3RyaW5nLW1hcCc7XHJcbmltcG9ydCByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzIGZyb20gJy4uL3V0aWxzL29iamVjdC9yZW1vdmUtdW5kZWZpbmVkLXByb3BlcnRpZXMnO1xyXG5pbXBvcnQgeyBDSElMRFJFTl9UT19BUFBFTkRfUFJPUCB9IGZyb20gJy4vcmVhY3QtY29udGVudCc7XHJcbmltcG9ydCB7IGdldENvbXBvbmVudENsYXNzIH0gZnJvbSAnLi9yZWdpc3RyeSc7XHJcblxyXG5jb25zdCBERUJVRyA9IGZhbHNlO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhY3ROb2RlKG5vZGU6IGFueSk6IG5vZGUgaXMgUmVhY3ROb2RlIHtcclxuICByZXR1cm4gKDxSZWFjdE5vZGU+bm9kZSkuc2V0UmVuZGVyUGVuZGluZ0NhbGxiYWNrICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2dpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIHJlbmRlciBhIFJlYWN0IGVsZW1lbnQgaW4gdGhlXHJcbiAqIERPTSwgd2l0aCB0aGUgbmVlZGVkIG1ldGhvZHMgdG8gZG8gc28uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVhY3ROb2RlIHtcclxuICAvLyBBY2Nlc3MgdG8gdGhlc2UgcHJvcGVydGllcyBhcmUgcmVzdHJpY3RlZCB0aHJvdWdoIHNldHRlcnMgYW5kIGZ1bmN0aW9uc1xyXG4gIC8vIHNvIHRoYXQgdGhlIGRpcnR5IFwicmVuZGVyIHBlbmRpbmdcIiBzdGF0ZSBvZiB0aGlzIG9iamVjdCBjYW4gYmUgcHJvcGVybHlcclxuICAvLyB0cmFja2VkIGFuZCBhbGwgbm9kZXMgd2l0aCBcInJlbmRlciBwZW5kaW5nXCIgY2FuIGJlIGZsdXNoZWQgYXQgdGhlIGVuZFxyXG4gIC8vIG9mIGEgcmVuZGVyIG9wZXJhdGlvbi5cclxuICBwcml2YXRlIF9wcm9wcyA9IHt9O1xyXG4gIHByaXZhdGUgX2NvbW1lbnQ6IHN0cmluZztcclxuICBwcml2YXRlIF90ZXh0OiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfdHlwZUlzUmVhY3RFbGVtZW50Q2xhc3M6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgcHJpdmF0ZSBfY2hpbGRyZW46IEFycmF5PFJlYWN0Tm9kZT4gPSBbXTtcclxuICBwcml2YXRlIF90eXBlTmFtZTogc3RyaW5nO1xyXG4gIHByaXZhdGUgX2NoaWxkcmVuVG9BcHBlbmQ6IEFycmF5PEhUTUxFbGVtZW50IHwgTm9kZT4gPSBbXTtcclxuICBwcml2YXRlIF9yZW5kZXJlZERvbUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gIHByaXZhdGUgX3BhcmVudDogSFRNTEVsZW1lbnQgfCBSZWFjdE5vZGU7XHJcbiAgcHJpdmF0ZSBfaXNOb3RSZW5kZXJhYmxlOiBib29sZWFuO1xyXG4gIHByaXZhdGUgX2lzRGVzdHJveVBlbmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBwcml2YXRlIF9pc1JlbmRlclBlbmRpbmcgPSB0cnVlO1xyXG5cclxuICBnZXQgZG9tRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZERvbUVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBzZXQgcGFyZW50KHBhcmVudDogSFRNTEVsZW1lbnQgfCBSZWFjdE5vZGUpIHtcclxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBhcmVudCgpOiBIVE1MRWxlbWVudCB8IFJlYWN0Tm9kZSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNob3VsZFJlbmRlcigpIHtcclxuICAgIHJldHVybiAhdGhpcy5faXNOb3RSZW5kZXJhYmxlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRlc3Ryb3lQZW5kaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzRGVzdHJveVBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHR5cGU/OiBSZWFjdC5SZWFjdFR5cGUgfCBzdHJpbmcpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgdGhpcy5fdHJ5UmVzb2x2ZVR5cGVJc1JlYWN0RWxlbWVudENsYXNzKCk7XHJcbiAgfVxyXG5cclxuICBzZXRSZW5kZXJQZW5kaW5nQ2FsbGJhY2sgPSAoKSA9PiBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBUcmFjayBhbGwgcGVuZGluZyByZW5kZXIgb3BlcmF0aW9ucyBpbnRlcm5hbGx5IGFuZCBzZXQgZmxhZyBvblxyXG4gICAqIHJlbmRlcmVyIGZhY3Rvcnkgc28gdGhhdCBhIGZsdXNoIG9wZXJhdGlvbiBjYW4gYmUgc2NoZWR1bGVkIGZvclxyXG4gICAqIHRoZSBcImVuZFwiIG9mIHJlbmRlci5cclxuICAgKi9cclxuICBzZXRSZW5kZXJQZW5kaW5nKCkge1xyXG4gICAgdGhpcy5zZXRSZW5kZXJQZW5kaW5nQ2FsbGJhY2soKTtcclxuICAgIHRoaXMuX2lzUmVuZGVyUGVuZGluZyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYXJrcyB0aGUgbm9kZSB0byBiZSByZW1vdmVkIGZyb20gdGhlIERPTSBpbiB0aGUgbmV4dCByZW5kZXIgY3ljbGUuXHJcbiAgICovXHJcbiAgZGVzdHJveU5vZGUoKSB7XHJcbiAgICB0aGlzLnNldFJlbmRlclBlbmRpbmcoKTtcclxuICAgIHRoaXMuX2lzRGVzdHJveVBlbmRpbmcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gdGhlIG5vZGUuXHJcbiAgICogQG5vdGUgdGhlIHZhbHVlIGNhbiBvbmx5IGJlIGEgYHN0cmluZ2AuIFNlZSBgc2V0UHJvcGVydHlgIGZvciBvdGhlciB1c2UtY2FzZXMuXHJcbiAgICogQHNlZSBgUmVuZGVyZXIyI3NldEF0dHJpYnV0ZWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWUuXHJcbiAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHsgW25hbWVdOiB2YWx1ZSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBhdHRyaWJ1dGVzIG9uIHRoaXMgbm9kZS5cclxuICAgKiBOb3RlIHRoYXQgdmFsdWVzIGNhbiBvbmx5IGJlIG9mIHR5cGUgYHN0cmluZ2AuIFNlZSBgc2V0UHJvcGVydGllc2AgZm9yIG90aGVyIHVzZS1jYXNlcy5cclxuICAgKiBAc2VlIGBSZW5kZXJlcjIjc2V0QXR0cmlidXRlYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIHRoZSBhdHRyaWJ1dGVzIHRvIHNldC5cclxuICAgKi9cclxuICBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IFN0cmluZ01hcDxzdHJpbmc+KSB7XHJcbiAgICB0aGlzLnNldFByb3BlcnRpZXMoYXR0cmlidXRlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgcHJvcCBpbiB0aGUgdW5kZXJseWluZyBSZWFjdCBlbGVtZW50LlxyXG4gICAqIEBzZWUgYFJlbmRlcmVyMiNzZXRQcm9wZXJ0eWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRQcm9wZXJ0eShuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcclxuICAgIHRoaXMuc2V0UHJvcGVydGllcyh7IFtuYW1lXTogdmFsdWUgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaWtlIGBzZXRQcm9wZXJ0eWAgYnV0IGZvciBtdWx0aXBsZSBwcm9wcyBhdCBvbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHByb3BlcnRpZXMgQW4gb2JqZWN0IHdpdGggdGhlIHByb3BzLlxyXG4gICAqL1xyXG4gIHNldFByb3BlcnRpZXMocHJvcGVydGllczogU3RyaW5nTWFwKSB7XHJcbiAgICB0aGlzLnNldFJlbmRlclBlbmRpbmcoKTtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fcHJvcHMsIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMocHJvcGVydGllcykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgcHJvcCBvciBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgdW5kZXJseWluZyBSZWFjdCBlbGVtZW50LlxyXG4gICAqIEBzZWUgYFJlbmRlcmVyMiNyZW1vdmVBdHRyaWJ1dGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXHJcbiAgICogQHBhcmFtIGNoaWxkTmFtZSBfT3B0aW9uYWxfIEEgcHJvcGVydHkgb2YgYG5hbWVgIHRvIHJlbW92ZSBpbnN0ZWFkLlxyXG4gICAqIEByZXR1cm5zIHRoZSBkZWxldGVkIHByb3BlcnR5XHJcbiAgICovXHJcbiAgcmVtb3ZlUHJvcGVydHkobmFtZTogc3RyaW5nLCBjaGlsZE5hbWU/OiBzdHJpbmcpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgaWYgKGNoaWxkTmFtZSkge1xyXG4gICAgICByZXR1cm4gZGVsZXRlIHRoaXMuX3Byb3BzW25hbWVdW2NoaWxkTmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9wcm9wc1tuYW1lXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIGRpcmVjdCBjaGlsZCBvZiB0aGlzIG5vZGUuXHJcbiAgICogQHNlZSBgUmVuZGVyZXIyI2FkZENoaWxkYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZC5cclxuICAgKi9cclxuICBhZGRDaGlsZChub2RlOiBSZWFjdE5vZGUpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaChub2RlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIGRpcmVjdCBjaGlsZCBvZiB0aGlzIG5vZGUuXHJcbiAgICogQHNlZSBgUmVuZGVyZXIyI3JlbW92ZUNoaWxkYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZS5cclxuICAgKi9cclxuICByZW1vdmVDaGlsZChub2RlOiBSZWFjdE5vZGUpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgdGhpcy5fY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gY2hpbGQgIT09IG5vZGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FzdCB0aGUgbm9kZSB0byBhIGNvbW1lbnQgbm9kZS5cclxuICAgKiBAc2VlIGBSZW5kZXJlcjIjY3JlYXRlQ29tbWVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHRleHQgaW4gdGhlIGNvbW1lbnQgdG8gcmVuZGVyLlxyXG4gICAqIEByZXR1cm5zIGl0c2VsZi5cclxuICAgKi9cclxuICBhc0NvbW1lbnQodmFsdWU6IHN0cmluZykge1xyXG4gICAgdGhpcy5zZXRSZW5kZXJQZW5kaW5nKCk7XHJcbiAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9jb21tZW50ID0gdmFsdWU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhc3QgdGhlIG5vZGUgdG8gYSB0ZXh0IG5vZGUuXHJcbiAgICogQHNlZSBgUmVuZGVyZXIyI2NyZWF0ZVRleHRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZhbHVlIHRoZSB0ZXh0IHRvIHJlbmRlci5cclxuICAgKiBAcmV0dXJucyBpdHNlbGYuXHJcbiAgICovXHJcbiAgYXNUZXh0KHZhbHVlOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgdGhpcy50eXBlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fdGV4dCA9IHZhbHVlO1xyXG5cclxuICAgIC8vIFNraXAgYXBwZW5kaW5nIGFuZCByZW5kZXJpbmcgb2YgZW1wdHkgdGV4dCBub2Rlcy4gVGhpcyBtYXkgY2F1c2UgYSBidWdcclxuICAgIC8vIGlmIGEgc2luZ2xlIHNwYWNlIGlzIGRlc2lyZWQuLi5cclxuICAgIGlmICghdmFsdWUgfHwgIXZhbHVlLnRyaW0oKSkge1xyXG4gICAgICB0aGlzLl9pc05vdFJlbmRlcmFibGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVyIHRoZSBub2RlIHRvIHRoZSBET00sIG9yIHVubW91bnQgaXQsIGFzIG5lY2Vzc2FyeS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGl0c2VsZi5cclxuICAgKi9cclxuICByZW5kZXIoKTogUmVhY3ROb2RlIHtcclxuICAgIC8vIE9ubHkgY29tcGxldGUgcmVuZGVyIG9wZXJhdGlvbnMgZm9yIFJlYWN0Tm9kZXMgdGhhdCBhcmUgcGFyZW50ZWQgYnkgSFRNTEVsZW1lbnRzLlxyXG4gICAgLy8gVGhvc2UgdGhhdCBhcmUgcGFyZW50ZWQgYnkgb3RoZXIgUmVhY3ROb2RlcyB3aWxsIGJlIHJlbmRlcmVkIHJlY3Vyc2l2ZWx5IGJ5IHRoZWlyXHJcbiAgICAvLyBwYXJlbnQuXHJcbiAgICBpZiAoIWlzUmVhY3ROb2RlKHRoaXMuX3BhcmVudCkpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzRGVzdHJveVBlbmRpbmcgJiYgdGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgaWYgKERFQlVHKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3ROb2RlID4gcmVuZGVyID4gZGVzdHJveSA+IG5vZGU6JywgdGhpcy50b1N0cmluZygpLCAncGFyZW50OicsIHRoaXMucGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLl9wYXJlbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5faXNSZW5kZXJQZW5kaW5nKSB7XHJcbiAgICAgICAgaWYgKERFQlVHKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3ROb2RlID4gcmVuZGVyID4gbm9kZTonLCB0aGlzLnRvU3RyaW5nKCksICdwYXJlbnQ6JywgdGhpcy5wYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJdCBpcyBleHBlY3RlZCB0aGF0IHRoZSBlbGVtZW50IHdpbGwgYmUgcmVjcmVhdGVkIGFuZCByZS1yZW5kZXJlZCB3aXRoIGVhY2ggYXR0cmlidXRlIGNoYW5nZS5cclxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZW5kZXJpbmctZWxlbWVudHMuaHRtbFxyXG4gICAgICAgIFJlYWN0RE9NLnJlbmRlcih0aGlzLl9yZW5kZXJSZWN1cnNpdmUoKSBhcyBSZWFjdC5SZWFjdEVsZW1lbnQ8e30+LCB0aGlzLl9wYXJlbnQpO1xyXG4gICAgICAgIHRoaXMuX2lzUmVuZGVyUGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBlbmRzIGEgY2hpbGQuXHJcbiAgICpcclxuICAgKiBAc2VlIGBSZW5kZXJlcjIjYXBwZW5kQ2hpbGRgLlxyXG4gICAqIEBub3RlIFRoaXMgaXMgY2FsbGVkIGJ5IEFuZ3VsYXIgY29yZSB3aGVuIHByb2plY3RlZCBjb250ZW50IGlzIGJlaW5nIGFkZGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHByb2plY3RlZENvbnRlbnQgdGhlIGNvbnRlbnQgdG8gcHJvamVjdC5cclxuICAgKi9cclxuICBhcHBlbmRDaGlsZChwcm9qZWN0ZWRDb250ZW50OiBIVE1MRWxlbWVudCB8IE5vZGUpIHtcclxuICAgIGlmIChERUJVRykge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICdSZWFjdE5vZGUgPiBhcHBlbmRDaGlsZCA+IG5vZGU6JyxcclxuICAgICAgICB0aGlzLnRvU3RyaW5nKCksXHJcbiAgICAgICAgJ3Byb2plY3RlZENvbnRlbnQ6JyxcclxuICAgICAgICBwcm9qZWN0ZWRDb250ZW50LnRvU3RyaW5nKCkudHJpbSgpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9jaGlsZHJlblRvQXBwZW5kLnB1c2gocHJvamVjdGVkQ29udGVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbm90ZSBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cclxuICAgKi9cclxuICB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgaWYgKHRoaXMuX3R5cGVOYW1lKSB7XHJcbiAgICAgIHJldHVybiBgWyR7dGhpcy5fdHlwZU5hbWV9IFJlYWN0Tm9kZV1gO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl90ZXh0KSB7XHJcbiAgICAgIHJldHVybiAnW3RleHQgUmVhY3ROb2RlXSc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2NvbW1lbnQpIHtcclxuICAgICAgcmV0dXJuICdbY29tbWVudCBSZWFjdE5vZGVdJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJ1t1bmRlZmluZWQgUmVhY3ROb2RlXSc7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9yZW5kZXJSZWN1cnNpdmUoa2V5Pzogc3RyaW5nKTogUmVhY3QuUmVhY3RFbGVtZW50PHt9PiB8IHN0cmluZyB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuXHJcbiAgICAgID8gdGhpcy5fY2hpbGRyZW4ubWFwKChjaGlsZCwgaW5kZXgpID0+IGNoaWxkLl9yZW5kZXJSZWN1cnNpdmUoaW5kZXgudG9TdHJpbmcoKSkpXHJcbiAgICAgIDogW107XHJcblxyXG4gICAgaWYgKHRoaXMuX3RleHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcHJvcHNbQ0hJTERSRU5fVE9fQVBQRU5EX1BST1BdID0gdGhpcy5fY2hpbGRyZW5Ub0FwcGVuZDtcclxuXHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgIHRoaXMuX3Byb3BzWydrZXknXSA9IGtleTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBKdXN0IGhhdmluZyBzb21lIHByb3BzIG9uIGEgUmVhY3QgZWxlbWVudCBjYW4gY2F1c2UgaXQgdG9cclxuICAgIC8vIGJlaGF2ZSB1bmRlc2lyYWJseSwgYW5kIHNpbmNlIHRoZSB0ZW1wbGF0ZXMgYXJlIGhhcmQtY29kZWQgdG8gcGFzc1xyXG4gICAgLy8gYWxsIElucHV0cyBhbGwgdGhlIHRpbWUsIHRoZXkgcGFzcyBgdW5kZWZpbmVkYCB2YWx1ZXMgdG9vLlxyXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoZXNlIGFyZSByZW1vdmVkLlxyXG4gICAgLy8gQWRkaXRpb25hbGx5LCB0aGVyZSBhcmUgc29tZSB0aGluZ3MgdGhhdCBBbmd1bGFyIHRlbXBsYXRpbmcgZm9yYmlkcyxcclxuICAgIC8vIGFuZCBzdG9wcyBhdC1jb21waWxlIHRpbWUgKHdpdGggZXJyb3JzKSwgc3VjaCBhcyBgSW5wdXRgcyBiZWluZyBwcmVmaXhlZCB3aXRoIGBvbmAuXHJcbiAgICAvLyBTaW5jZSBSZWFjdCBkb2VzIG5vdCBoYXZlIHRoZSBub3Rpb24gb2YgYE91dHB1dGBzIGFzIEFuZ3VsYXIgKHRoZXkgYXJlIGp1c3QgcHJvcHMgb2YgdHlwZSBmdW5jdGlvbiwgZXNzZW50aWFsbHkgY2FsbGJhY2tzKS5cclxuICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlLCBieSBjb252ZW50aW9uLCBwcmVmaXggYW55IFBhc2NhbENhc2VkIHByb3Agd2l0aCBgb25gIGhlcmUsIGFmdGVyIHRoZSB0ZW1wbGF0ZSBoYXMgYWxyZWFkeSBiZWVuIGNvbXBpbGVkLlxyXG4gICAgY29uc3QgY2xlYXJlZFByb3BzID0gdGhpcy5fdHJhbnNmb3JtUHJvcHMocmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyh0aGlzLl9wcm9wcykpO1xyXG5cclxuICAgIGlmIChERUJVRykge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgJ1JlYWN0Tm9kZSA+IHJlbmRlclJlY3Vyc2l2ZSA+IHR5cGU6JyxcclxuICAgICAgICB0aGlzLnRvU3RyaW5nKCksXHJcbiAgICAgICAgJ3Byb3BzOicsXHJcbiAgICAgICAgdGhpcy5fcHJvcHMsXHJcbiAgICAgICAgJ2NoaWxkcmVuOicsXHJcbiAgICAgICAgY2hpbGRyZW5cclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRoaXMudHlwZSwgY2xlYXJlZFByb3BzLCBjaGlsZHJlbi5sZW5ndGggPiAwID8gY2hpbGRyZW4gOiB1bmRlZmluZWQpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfdHJhbnNmb3JtUHJvcHM8VFByb3BzIGV4dGVuZHMgb2JqZWN0Pihwcm9wczogVFByb3BzKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocHJvcHMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgY29uc3QgW25ld0tleSwgbmV3VmFsdWVdID0gdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgPyBba2V5LCB2YWx1ZV0gOiB0aGlzLl90cmFuc2Zvcm1Qcm9wKGtleSwgdmFsdWUpO1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW25ld0tleV06IG5ld1ZhbHVlIH0pO1xyXG4gICAgfSwge30pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfdHJhbnNmb3JtUHJvcDxUVmFsdWUgPSBhbnk+KG5hbWU6IHN0cmluZywgdmFsdWU6IFRWYWx1ZSk6IFtzdHJpbmcsIFRWYWx1ZV0ge1xyXG4gICAgLy8gcHJvcCBuYW1lIGlzIGNhbWVsQ2FzZWQgYWxyZWFkeVxyXG4gICAgY29uc3QgZmlyc3RMZXR0ZXIgPSBuYW1lWzBdO1xyXG4gICAgaWYgKGZpcnN0TGV0dGVyID09PSBmaXJzdExldHRlci50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgIHJldHVybiBbbmFtZSwgdmFsdWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHByb3AgbmFtZSBpcyBQYXNjYWxDYXNlZCAmIGlzIGEgZnVuY3Rpb24gLSBhc3N1bWluZyByZW5kZXIgcHJvcCBvciBjYWxsYmFjayBwcm9wIHRoYXQgaGFzIHJldHVybiB2YWx1ZVxyXG4gICAgLy8gTk9URTogQW5ndWxhciBkb2Vzbid0IGFsbG93IHBhc3NpbmcgQElucHV0cyB0aGF0IGFyZSBwcmVmaXhlZCB3aXRoIFwib25cIi4gVGhpcyBpcyB1c2VmdWwgZm9yIHJlbmRlciBwcm9wcyBhbmQgcHJvcGVydGllcyByZXByZXNlbnRpbmcgdGhlIFwib25cIiBzdGF0ZSAoZm9yIGV4YW1wbGUsIFRvZ2dsZSkuXHJcbiAgICAvLyBBcyBhIGNvbnZlbnRpb24sIGFueSBASW5wdXQgdGhhdCBzdGFydHMgd2l0aCBhIGNhcGl0YWwgbGV0dGVyIGlzIHByZWZpeGVkIHdpdGggXCJvblwiIHdoZW4gcGFzc2VkIGFzIGEgcHJvcCB0byB0aGUgdW5kZXJseWluZyBSZWFjdCBjb21wb25lbnQuXHJcbiAgICByZXR1cm4gW2BvbiR7bmFtZX1gLCB2YWx1ZV07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF90cnlSZXNvbHZlVHlwZUlzUmVhY3RFbGVtZW50Q2xhc3MoKSB7XHJcbiAgICBpZiAodGhpcy5fdHlwZUlzUmVhY3RFbGVtZW50Q2xhc3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBDb21tZW50cyBhbmQgdGV4dCBoYXZlIG5vIHR5cGUuXHJcbiAgICAgIGlmICghdGhpcy50eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdG9yZSB0aGUgbmFtZSBvZiB0aGUgdHlwZSBmb3IgdGhlIHRvU3RyaW5nIG1lc3NhZ2UgKGRlYnVnZ2luZykuXHJcbiAgICAgIHRoaXMuX3R5cGVOYW1lID0gdGhpcy50eXBlIGFzIHN0cmluZztcclxuXHJcbiAgICAgIC8vIEF0dGVtcHQgdG8gcmVzb2x2ZSB0aGUgdHlwZSBhcyBhIFJlYWN0IEVsZW1lbnQgY2xhc3MgbmFtZS90eXBlLlxyXG4gICAgICAvLyBTaW5jZSBBbmd1bGFyIHRlbXBsYXRlcyBhcmUganVzdCBzdHJpbmdzLCB3ZSBjYW4ndCBpbmNsdWRlIHR5cGVzIGluIHRoZW0uXHJcbiAgICAgIC8vIFRoZXJlZm9yZSwgd2UgdXNlIHRoZSBjb21wb25lbnQgcmVnaXN0cnkgdG8gcmVzb2x2ZSB0aGUgdHlwZSBvZiBhIGNvbXBvbmVudCBmcm9tIGEgc3RyaW5nLlxyXG4gICAgICBpZiAodHlwZW9mIHRoaXMudHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBnZXRDb21wb25lbnRDbGFzcyh0aGlzLnR5cGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0eXBlIGlzIHN0aWxsIGEgc3RyaW5nLCB0aGVuIG5vIFJlYWN0IEVsZW1lbnQgbWF0Y2hlcyB0aGlzIHN0cmluZy5cclxuICAgICAgdGhpcy5fdHlwZUlzUmVhY3RFbGVtZW50Q2xhc3MgPSB0eXBlb2YgdGhpcy50eXBlICE9PSAnc3RyaW5nJztcclxuXHJcbiAgICAgIGlmIChERUJVRykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdE5vZGUgPiB0cnlSZXNvbHZlVHlwZUlzUmVhY3RFbGVtZW50Q2xhc3MgPiB0eXBlOicsIHRoaXMuX3R5cGVOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=